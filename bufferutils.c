/**	@file bufferutils.c	Functions that support the tBuffer structure.		tBuffer is an object that maintains all the state associated with	the stream being processed. The parser stuffs the incoming stream	into the tBuffer, and flushes it when it encounters certain syntax	boundaries as it does so. 	@version 0.9	@author Paul Chambers	@date 2005-2006*//* $Header$ */#include "common.h"#include <stdio.h>#include "stringutils.h"#include "bufferutils.h"#include "parser.h"static void initRange(tRange *rng);/*	private functions*//**	@internal	shorthand to zero a tRange	@param[out] 	rng 	a pointer to tRange*/static void initRange(tRange *rng){	rng->count	= 0;	rng->start	= NULL;	rng->end 	= NULL;}/*	public functions*//**	Clears a tBuffer back to the 'empty' state.	@note should not be used to initialize a tBuffer - see initBuffer()	@param[out] 	buf 	the tBuffer to clear*/void clearBuffer(tBuffer *buf){	buf->ptr = &buf->data[0];		buf->commentStart = NULL;	buf->statementStart = NULL;	if (buf->todos != NULL)		freeStringList(&(buf->todos));	if (buf->notes != NULL)		freeStringList(&(buf->notes));	if (buf->retvals != NULL)		freeStringList(&(buf->retvals));	buf->fileComment = false;		initRange(&buf->description);	initRange(&buf->function);	initRange(&buf->arglist);	initRange(&buf->body);}/**	Initialize a tBuffer object.	@param[out] 	buf 	the tBuffer to initialize	@param[in]	 	file 	the output file*/void initBuffer(tBuffer *buf, FILE *file){	buf->end = &buf->data[qBufferSize];	buf->file = file;	buf->commentStart = NULL;	buf->statementStart = NULL;	buf->todos = NULL;	buf->notes = NULL;	buf->retvals = NULL;	clearBuffer(buf);}/**	output a block of characters within a tBuffer.	Typically used to output a range of characters	within a tBuffer.	@param[in] 	buf 	used to identify the output file	@param[in] 	start 	the first character to output	@param[in] 	end 	points just after the last character to output*/void dumpBlock(tBuffer *buf, const char *start, const char *end){	size_t count = (end - start);	if (count > 0)		fwrite(start, sizeof(char), count, buf->file);}/**	Brief description needed.	Followed by a more complete description.	@param[in,out] 	buf 	a pointer to tBuffer	@param[in] 	c 	int	@return int	@retval	0	all is well	@retval 1	buffer full*/int emitChar(tBuffer *buf, int c){	*(buf->ptr) = (char)c;	++(buf->ptr);		return (buf->ptr >= buf->end);}